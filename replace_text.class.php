<?
/*
	Класс для вставки в текст ссылок вместо определённых словосочетания. Для SEO.
	Задача: найти текст по определённому шаблону и заменить его на ссылку.
	например: найти слово "линз*", если перед ним есть слово "контактн*", то берём эти 2 слова и любое перед ними.
	Таким образом, подходят словосочетания "мягких контактных линз", "по контактным линзам" и т.д.

	Причина замены с помощью substr_replace а не str_replace:
	менять необходимо не все вхождения - в ссылках, в элементах title и alt замена не нужны по очевидным причинам.
	Поэтому сначала текст проверяется на наличие в нём элементов, в которых замена не нужна. При нахождении они заменяются нулями.
	В новом тексте ищутся вхождения для замены на ссылки. Запоминаются их позиции и по ним уже меняются в исходном тексте, 
	не затрагивая элементы, в которых замена не нужна.

	п.с. Класс не оптимален. Не во всех случаях сработает корректно. Надо доделывать.

*/
class ReplaceText {
	 public function getDelSpecCh($text) {
        $text = strtr($text, array( ':' => '', '}' => '', '"' => '', '{' => '', "(" => "", ")" => "", 
                                    '&' => '', '$' => '', '!' => '', '#' => '', '№' => '', ';' => '', '%' => '', '^' => '', 
                                    '?' => '', '*' => '', '=' => '', '+' => '', '[' => '', ']' => '', '/' => '', '>' => '', 
                                    '<' => '', ',' => '', '|' => '', "'" => "", "_" => "", "." => ''));
        return $text;
    }

    // метод заменяет в тексте теги (со всем содержимым) из массива $tagarr и параметры alt и title тегов (всех) на нули. 
    public function replaseZero($text) {
        // error_log("INPUT");
        // error_log($text);
        $tagarr = array('a', 'h1');
        $str = '';
        preg_match_all("/(<([\w]+)[^>]*>)(.*?)(<\/\\2>)/", $text, $searchtag, PREG_SET_ORDER);
        preg_match_all('/(alt|title)=((\'|")[^(\'|")]*(\'|"))/i', $text, $titlealt, PREG_SET_ORDER);

        foreach ($searchtag as $tag) {
            if (in_array($tag[2], $tagarr)){
                $str = str_pad(0, strlen($tag[0]), '0');
                $text = str_replace($tag[0], $str, $text);
            }
        }

        foreach ($titlealt as $meta) {
            $str = str_pad(0, strlen($meta[0]), '0');
            $text = str_replace($meta[0], $str, $text);
        }
        // error_log("OUTPUT");
        // error_log($text);
        return $text;
    }

    /**
	*	Метод замены текста на ссылки
	*	@param string $text - текст, в котором будет производиться замена.
	*	@param array $word - массив слов, по которым необходимо искать заменяемый текст. Первое слово является ключевым - поиск будет начинать с него.
	*	Если передан не массив, то переданный текст будет считаться одним словом.
	*	@param int $countword - количество слов, которые будут в фразе замены. Не может быть меньше одного.
	*	@param string $url - ссылка, на которую будет ссылаться замена
	*	@param int $side - в какую сторону от основного (первого) слова производить поиск последующих. -1 - влево(в сторону начала текста). 1(по умолчанию) - вправо.
	*	@return string изменённый текст
	*/
    public function addLink($text, $word, $countword, $url, $side = 1) {
        $arrword = array();
        // если параметры некорректны, просто возвращаем текст обратно, без обработки
        if (!is_string($text) or !is_int($countword) or $countword < 1 or abs($side) != 1 or $url == '' or !admin_id){
            return $text;
        }
        // одно слово(цифра) вместо массива слов тоже будет обработано
        if (!is_array($word)) {
            $arrword[] = $word;
        } else {
            $arrword = $word;
        }
        // если в тексте встречается первое слово из массива (основное), то начинаем работу
        if (strstr($text, $arrword[0])){
                // замена на нули. Это сделано для того, что в ссылках, в заголовках или в параметрах title не менять текст на ссылки.
                $newtext = $this->replaseZero($text);
                $explval = explode(' ', $newtext);
                $seapos = array();
                // перебираем полученный массив слов, созданные разделением текста по пробелам
                foreach ($explval as $key => $oneword) {
                    // ищем слово, которое начинается со слова, переданного первым в массиве слов для поиска
                    if(substr($oneword, 0, strlen($arrword[0])) == $arrword[0]) {
                        $ok = true;
                        $tempstr = '';
                        // проверяем, совпадают ли последующие (предыдущие) слова в тексте со словами, переданными в массиве для поиска
                        for ($i = 1; $i < count($arrword); $i++) {
                            $ok*= substr($explval[($key + $i * $side)], 0, strlen($arrword[$i])) == $arrword[$i];
                        }
                        if ($ok) {
                            // получаем фразу для замены, если по тексту необходимо двигаться в сторону начала
                            // TO DO: придумать всевозможные варианты комбинаций текста и тегов и корерктно их обработать.
                            if ($side < 0) {                                
                                for ($i = $countword - 1; $i > 0; $i--) { 
                                    $tempstr.= $explval[($key + $i * $side)] . ' ';
                                }
                                $tempstr.= $this->getDelSpecCh(strip_tags($oneword));
                            } else {
                                $tempstr.= $this->getDelSpecCh(strip_tags($oneword));
                                for ($i = 1; $i < $countword; $i++) { 
                                    $tempstr.= ' ' . $explval[($key + $i * $side)];
                                }
                            }
                            $searchstring = $tempstr;
                            $n = 0;
                            // получаем позиции в тексте фраз, которые подлежать замене. Пишем в массив {позиция => фраза}
                            while (strpos($newtext, $searchstring, $n) !== false) {

                                $temp = strpos($newtext, $searchstring, $n);
                                // добавлять, если на этой позиции ещё не найдено элемента или если найденный элемент короче по длине
                                if (!$seapos[$temp] or strlen($seapos[$temp] < $searchstring)) {
                                	$seapos[$temp] = $searchstring;
                                }
                                $n = $temp + strlen($searchstring);

                            }
                        }
                    }
                }
            // дабы не ошибиться в позициях, необходимо заменять фразы в тексте с конца текста. Для этого ключи массива (позиции) сортируем в сторону уменьшения
            krsort($seapos);
            // замена найденных фраз на ссылки
            foreach ($seapos as $key => $value) {
                $text = substr_replace($text, '<a href="' . $url . '">' . $value . '</a>', $key, strlen($value));                
            }
        }
        return $text;
    }
}

?>
